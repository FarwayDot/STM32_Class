/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 * EXPLICACIÓN DEL SYSTICK
 *
 * El contador SysTick es un contador de 24 bits que va decrementando su valor.
 * Por lo tanto, cuenta desde ( 2^24 - 1 ) hasta 0: Un total de 2^24 pulsos.
 *
 * Entonces: Periodo : (( 2^24 - 1 ) + 1) * 1/Fosc
 *
 * Porque (2^24-1) + 1?, 2^24 - 1 es el valor máximo del contador, luego, se le suma +1 porque
 * es el pulso faltante para que pase del valor 0 al valor máximo nuevamente.
 *
 * Imaginemos que empieza a contar en un valor de 5.
 * Significa que luego de 5 pulsos llegara a la cuenta de 0. Luego de 1 pulso adicional, el contador
 * inicia la cuenta nuevamente.
 * Por lo tanto, truncar un valor de 5 equivale a tener un periodo de (5+1).
 *
 * Si truncamos este valor en cualquier otro por ejemplo:
 *
 * SEGÚN MANUAL DE PROGRAMACIÓN STM32F4
 *
 * Aquí se habla sobre cyclos de reloj:
 *
 * Si quieres 100 cyclos de reloj, entonces debes cargar en RELOAD un valor de 99.
 * Se observa que -1 de lo que quieres.
 *
 * Y si quiero tiempos?
 *
 * Quiero 5ms y tengo una frecuencia de reloj de 16Mhz -> significa que T = 1/16 us
 *
 * Cuantos pulsos necesito para llegar a 5ms -> factor = tiempo/T = 16M * 5m cyclos
 * Por lo tanto, en reload irá (16M * 5m - 1)
 *
 * delay_ms(time)
 * {
 * 	SysTick -> RELOAD = (SytemCoreClock)*(5/1000) - 1;
 * }
 *
 * OJO: Tener en cuenta la frecuencia de reloj.
 *
 * Si F = 16Mhz -> Lo máximo que contará será  2097 ms (Por el valor del registro)
 * Si F = 84Mhz -> Lo máximo que contará será  399 ms (Por el valor del registro)
 *
 * Pasos:
 *
 * Desactivar SysTick
 * Configurar fuente de reloj
 * Reiniciar el valor que tiene el systick (luego del reset, tiene cualquier valor)
 * Cargar el valor deseado: X, calclar antes
 * Activamos systick
 * Esperar a que la bandera de interrupción se active
 * Apagar systick
 *
 */

/* Inclución de librerías */
#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "RCC.h"
#include "SysTick.h"

#define GPIO_OUTPUT(GPIOx,PIN)	{GPIOx -> MODER &= ~(1U<<2*PIN);	\
								 GPIOx -> MODER |= (1U<<2*PIN);		\
								 GPIOx -> OTYPER&= ~(1U<<PIN);		\
								 GPIOx -> OSPEEDR |= 0x3U<<2*PIN;	\
								 GPIOx -> PUPDR &= ~(0x3U<<PIN*2);}

/* Tipos, estructuras y enumeraciones */

/* Variables globales */

/* Prototipo de funciones */

/*Función principal */

int main(void)
{
	PLL_Source_t val = HSI_SOURCE;

	RCC -> AHB1ENR |= RCC_AHB1ENR_GPIOAEN; 	//Enable CLK port A
	GPIO_OUTPUT(GPIOA, 5) //PA5, puss pull, no pull up/down, high speed

	PLL_Config(val);

	delay_init();

	while(1)
	{
		GPIOA -> ODR ^= 1U<<5;
		delay_us(200);
	}

}

/***************** Definición de funciones *****************/



