/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 * NVIC: Nestered Vector Interrupt Controller
 *
 * Se encarga de gestionar y ejecutar las interrupciones del sistema
 *
 * Cada interrupción posee una posición única(Esto se ve en una tabla en el reference manual).
 * Las posiciones pueden ser positivas o negativas.
 * Las negativas son propias de la arquitectura, las positivas pertenecen a los periféricos.
 * Por ejemplo, ingregar a la variable SysTick_IRQn y se podrá ver el número -1.
 * Las posiciones no se pueden cambiar.
 *
 * Las interrupciones tiene un nivel de prioridad, puede ser negativa o positiva.
 * Las interrupciones más negativas son las de mayor prioridad y las más positivas poseen menor
 * prioridad.
 * Las prioridades pueden ser configuradas en su mayoría.
 *
 * EXTI: External Interrupt/Event Controller
 *
 * Es un controlador que te permite generar eventos o interrupciones a través de
 * los pinbes GPIO ya sea por un flanco de subida o de bajada.
 * Cada pin de configura de forma independiente.
 * El registro Pending Register (PR) indica el status del evento o interrupcion.
 *
 * Para congigurar una interrupción o evento (Ver gráfico en la sección de EXTI)
 *
 * Configurar el pin como entrada.
 * Configurar el flanco a detectar. (EXTI RTSR FTSR)
 * Configurar el pin como interrupción o evento (EXTI IMR o EMR)
 * Activar el periférico SYSCFG en RCC -> APB2ENR |= RCC_APB2ENR_SYSCFGEN; ya que este periférico se encarga
 * de enlazar el pin GPIO con el pin EXTI.
 * Enlazar el pin GPIO con la EXTI en SYSCFG -> EXTICR[X]; (Ver tabla y comprender el enlace)
 * Activar la interrupción en la NVIC a través NVIC_EnableIRQ y configurar priori a través NVIC_SetPriority
 *
 * Cuando se genera el event/interrupt el bit correspondiente del registro PR se activa.
 * Se limpia el request escibiendo un 1 nuevamente el pin.
 */

/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "GPIO_Config.h"
//#include "Config.h"
#include "RCC.h"
#include "Delay.h"

/* Definiciones*/

#define GPIO_PIN_13 		13
/* Tipos, estructuras y enumeraciones */


/* Variables globales */
uint8_t count = 0;
EXTI_Config_t exti13 = {.en = 1, .exti_pin = 13, .trigger = FALLING_IT, .priority = 8};


/* Prototipo de funciones */
//static void EXTI13_Config(uint32_t typeIT); //Aseguramos de solo utilizar la función en este archivo
void GPIO_EXTI_Callback(uint8_t pin);
void LED_Init(void);

/* Función principal */
int main(void)
{
	flash_config();
	PLL_Config(HSE_SOURCE);
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	GPIO_Input_Config(GPIOC, 13, PULL_NONE , &exti13);

	//User Led
	//GPIO_Output_Config(GPIOA, 5, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);

	//Output 1
	GPIO_Output_Config(GPIOA, 8, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIO_Output_Config(GPIOB, 10, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIO_Output_Config(GPIOB, 4, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIO_Output_Config(GPIOB, 5, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIO_Output_Config(GPIOB, 3, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);

	//Output 2
	GPIO_Output_Config(GPIOA, 6, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIO_Output_Config(GPIOA, 7, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIO_Output_Config(GPIOB, 6, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIO_Output_Config(GPIOC, 7, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIO_Output_Config(GPIOA, 9, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);

	while(1)
	{
		delay_ms(500);
		;

	}
}

/* Definición de funciones */

void GPIO_EXTI_Callback(uint8_t pin)
{
	static uint16_t i = 2;
	i++;

	if(pin == 13)
	{
		if(i!=128)
		{
			GPIO_Write(GPIOA, 5, i%2);

			GPIO_Write(GPIOA, 6, i%2);
			//GPIO_Write(GPIOA, 7, i%2);
			GPIO_Write_Toggle(GPIOA, 7);
			GPIO_Write(GPIOB, 6, i%2);
			GPIO_Write(GPIOC, 7, i%2);
			GPIO_Write(GPIOA, 9, i%2);

			GPIO_Write(GPIOA, 8, i%2);
			GPIO_Write(GPIOB, 10, i%2);
			GPIO_Write(GPIOB, 4, i%2);
			GPIO_Write(GPIOB, 5, i%2);
			GPIO_Write(GPIOB, 3, i%2);
		}
		else
		{
			i=2;
		}
	}
}
