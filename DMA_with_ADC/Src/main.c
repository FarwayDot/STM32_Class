/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "adc.h"
#include "stm32f4xx.h"

/*Definiciones*/

#define BUTTON_GPIO	GPIOC
#define BUTTON_PIN	13

#define AN0_GPIO	GPIOA
#define AN0_Pin		0		//IN0

#define AN1_GPIO	GPIOA
#define AN1_Pin		1		//IN1

#define AN4_GPIO	GPIOA
#define AN4_Pin		4		//IN4

EXTI_Config_t button_exti = {.en = 0}; //Desactivamos EXTI del GPIO

/* Tipos, estructuras y enumeraciones */

ADC1_Params_t adc1_config1 =	{		.resolution = ADC1_Res_12bit,
										.align_mode = ADC1_Right_Align,
										.clk_div = ADC1_PCLK_DIV4,
										.conversion_mode = ADC1_Single_Mode,
										.scan_mode = ADC1_Scan_On,
										.eocs_var = ADC1_At_Sequence,
										.adc_interrupt = ADC1_Interrupt_On
									};



/* Variables globales */
uint16_t pot0 = 0;
uint16_t pot1 = 0;
uint8_t flag_start = 0;
uint16_t adcData[6];

/* Prototipo de funciones */
void adc1_ch_config(void);
void adc_user_handler(); //Extern created in stm32f4xx_it.c
void DMA2_Stream4_Config(void);

/* Función principal */
int main(void)
{
	flash_config();
	PLL_Config(HSI_SOURCE);
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	printf("Configuracion del systick System Clock -> %lu\n",SystemCoreClock);

	/*GPIO Config*/
	GPIO_Output_Config(GPIOA, 5, PUPDR_NONE, OSPEEDR_HIGH, OTYPER_PP);
	GPIO_Input_Config(BUTTON_GPIO, BUTTON_PIN, PULL_NONE, &button_exti);
	GPIO_Analog_Config(AN0_GPIO, AN0_Pin, ADC1_Cycles_3);
	GPIO_Analog_Config(AN1_GPIO, AN1_Pin, ADC1_Cycles_3);
	adc1_config(&adc1_config1);
	printf("Configuracion de ADC\n");

	while(1)
	{




	}
}

/* Definición de funciones */
int __io_putchar(int ch)
{
	uint8_t c = ch & 0xFF;
	ITM_SendChar(c);
	return ch;
}


void adc_user_handler(void)
{
	//Luego de empezar el start, se esperará a que realice la conversión e ingresará a la función
	pot0 = ((uint16_t)(ADC1->DR & 0x0000FFFF));
	printf("Pot 0 -> %u\n", pot0);
}

void DMA2_Stream4_Config(void)
{
	//Habilitar reloj
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;

	//Deshabilitar stream en caso está habilitado
	DMA2_Stream4->CR &= ~DMA_SxCR_EN;

	//Verificar cambio (demora un poco debido a que termina de transferir data anterior)
	while(DMA2_Stream4->CR & DMA_SxCR_EN);

	//Deshabilitar LISR o HISR antes de habilitar stream
	DMA2->LIFCR |= ((0xF<<2) + 1U);

	//Seleccionar el peripheral address (En este caso del ADC en Memory Map + registro a leer)
	DMA2_Stream4->PAR = (uint32_t)(0x40012000 + 0x4C); //ADC Base + DR register
	//DMA2_Stream4->PAR = (uint32_t)&(ADC1->DR) //Equivalente

	//Seleccionar el memory address(Dirección del buffer donde se almacena)
	DMA2_Stream4->M0AR = (uint32_t)adcData;

	//Configurar el total número de datos a transferirse
	DMA2_Stream4->NDTR = 6;

	//Seleccionar el canal DMA
	DMA2_Stream4->CR &= ~DMA_SxCR_CHSEL_0; //Channel 0 del Stream 4

	//Se omite aquí un paso del reference manual

	//Configurar prioridad
	DMA2_Stream4->CR &= ~DMA_SxCR_PL;
	DMA2_Stream4->CR |= (0b11<<DMA_SxCR_PFCTRL_Pos); //High priority

	//Configurar FIFO
	DMA2_Stream4->FCR &= ~DMA_SxFCR_DMDIS; //Direct mode

	//Fifo threshold (no afecta en nada si utilizamos el direct mode)

	/*Configurar modo de transferencia, tamaño de datos, modo circutlar, etc*/

	//Peripheral address size offset
	DMA2_Stream4->CR &= ~DMA_SxCR_PINCOS; //None

	//Memory data size
	DMA2_Stream4->CR &= ~DMA_SxCR_MSIZE; //half word - 16 bit
	DMA2_Stream4->CR |= (0b01<<DMA_SxCR_MSIZE_Pos);

	//Peripheral data size
	DMA2_Stream4->CR &= ~DMA_SxCR_PSIZE; //half word - 16 bit
	DMA2_Stream4->CR |= (0b01<<DMA_SxCR_PSIZE_Pos);

	//Memory increment mode (el periférico es fijo)
	DMA2_Stream4->CR |= (1<<DMA_SxCR_MINC_Pos);

	//Modo circular
	DMA2_Stream4->CR |= (1<<DMA_SxCR_CIRC_Pos);

	//Configurar interrupciones


}








