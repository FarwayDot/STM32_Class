/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "Config.h"
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "spi.h"
#include "USART.h"


/*Definiciones*/

#define PIN_MAX6675_CS		9
#define GPIO_MAX6675_CS		GPIOA
#define MAX6675_CS			A, PIN_MAX6675_CS

#define MAX6675_CS_ON()		GPIOX_ODR(MAX6675_CS) = 0
#define MAX6675_CS_OFF()	GPIOX_ODR(MAX6675_CS) = 1

//LED
#define PIN_USER_LED	10
#define GPIO_USER_LED	GPIOA

/* Tipos, estructuras y enumeraciones */
uint8_t MAX6675_Value[2];
float val_temp = 0.0;
uint8_t len_data_text = 0;
uint8_t Data_Text[100] = {0};

/* Variables globales */

typedef struct
{
	uint8_t Dummy_bit; 	//D15
	uint16_t Data; 		//D14 - D3 0111 1111 1111 1000
	uint8_t Status; 	//D2
	uint8_t ID;			//D1
	uint8_t Three_State;//D0
}MAX6675_Data_t;

MAX6675_Data_t Data_Decod;

USARTx_Handle_t usart2_handle = {.pUSARTx = USART2};

USARTx_Config_t USART2_Config = { 	.USARTx = USART2,
									.baudrate = 115200,
									.m_bit = M_8BITS,
									.over_bit = OVER_16,
									.enable_parity = PARITY_DIS,
									.stop_bit = STOP_ONE,
									.priority = 1};


/* Prototipo de funciones */

void MAX6675_Init(void);
uint8_t MAX6675_Read(void);

/* Función principal */
int main(void)
{

	//Clock Config
	flash_config();
	PLL_Config(HSI_SOURCE);
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	//SPI Config
	SPI_Init(SPI1);

	//LED Config
	GPIO_Output_Config(GPIO_USER_LED, PIN_USER_LED, PUPDR_NONE, OSPEEDR_MEDIUM, OTYPER_PP);

	//Usart init
	USARTx_Init(&USART2_Config);

	//MAX Init
	MAX6675_Init();

	while(1)
	{
		MAX6675_Read();
		val_temp = ((float)Data_Decod.Data)*0.25;

		len_data_text = sprintf((char*)Data_Text, "Temp = %u.%u\r\n",(uint16_t)val_temp,(((uint16_t)val_temp)%4)*25);
		USARTx_Send_Data(USART2, Data_Text, len_data_text);

		GPIO_Write_Toggle(GPIO_USER_LED, PIN_USER_LED);

		delay_ms(750);
	}
}

/* Definición de funciones */

void MAX6675_Init(void)
{
	GPIO_Output_Config(GPIO_MAX6675_CS, PIN_MAX6675_CS, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	MAX6675_CS_OFF();
	return;
}

uint8_t MAX6675_Read(void)
{
	uint32_t val = 0;

	//Process to receive
	MAX6675_CS_ON();
	SPI_Master_Receive_Data(SPI1, MAX6675_Value, 2);
	MAX6675_CS_OFF();

	// MAX6675_Value[1] = D7  D6  D5  D4  D3  D2  D1 D0
	// MAX6675_Value[0] = D15 D14 D13 D12 D11 D10 D9 D8

	//D15 = 0
	//D14-D3 = DATA
	//D2 = 0 WHEN IT'S OK, 1 WHEN SENSOR IS OPEN
	//D1 = 0 ID
	//D0 = THREE-STATE

	val = (MAX6675_Value[0]<<8) | MAX6675_Value[1];
	Data_Decod.Dummy_bit = (val >> 15) & 0x1;
	Data_Decod.Data = (val >> 3) & 0x0FFF;
	Data_Decod.Status = (val >> 2) & 0x1;
	Data_Decod.ID = (val >> 1) & 0x1;
	Data_Decod.Three_State = (val >> 0) & 0x1;

	//Comprobar D15
	if(Data_Decod.Dummy_bit != 0) return 0; //Dummy byte incorrecto

	//Comprobar D2
	if(Data_Decod.Status != 0) return 1; //Sensor ins Open

	//Comprobar D1
	if(Data_Decod.Status != 0) return 2; //Sensor ID

	delay_ms(250);

	return 0;

}


