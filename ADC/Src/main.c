/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "adc.h"
#include "stm32f4xx.h"

/*Definiciones*/

#define BUTTON_GPIO	GPIOC
#define BUTTON_PIN	13

#define AN0_GPIO	GPIOA
#define AN0_Pin		0

#define AN1_GPIO	GPIOA
#define AN1_Pin		1

#define AN4_GPIO	GPIOA
#define AN4_Pin		4

EXTI_Config_t button_exti = {.en = 0};

/* Tipos, estructuras y enumeraciones */
#if MODE == SINGLE_NO_SCAN
ADC1_Params_t adc1_config1 =	{		.resolution = ADC1_Res_12bit,
										.align_mode = ADC1_Right_Align,
										.clk_div = ADC1_PCLK_DIV4,
										.conversion_mode = ADC1_Single_Mode,
										.scan_mode = ADC1_Scan_Off,
										.eocs_var = ADC1_At_Sequence,
										.adc_interrupt = ADC1_Interrupt_Off
									};
#elif MODE == CONTINUOUS_NO_SCAN
ADC1_Params_t adc1_config1 =	{		.resolution = ADC1_Res_12bit,
										.align_mode = ADC1_Right_Align,
										.clk_div = ADC1_PCLK_DIV4,
										.conversion_mode = ADC1_Continuous_Mode,
										.scan_mode = ADC1_Scan_Off,
										.eocs_var = ADC1_At_Sequence,
										.adc_interrupt = ADC1_Interrupt_Off
									};

#elif MODE == SINGLE_SCAN

ADC1_Params_t adc1_config1 =	{		.resolution = ADC1_Res_12bit,
										.align_mode = ADC1_Right_Align,
										.clk_div = ADC1_PCLK_DIV4,
										.conversion_mode = ADC1_Single_Mode,
										.scan_mode = ADC1_Scan_On,
										.eocs_var = ADC1_At_Sequence,
										.adc_interrupt = ADC1_Interrupt_Off
									};


#endif


/* Variables globales */
uint16_t pot0 = 0;
uint16_t pot1 = 0;

/* Prototipo de funciones */
void adc1_ch_config(void);


/* Función principal */
int main(void)
{
	flash_config();
	PLL_Config(HSI_SOURCE);
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	/*GPIO Config*/
	GPIO_Output_Config(GPIOA, 5, PUPDR_NONE, OSPEEDR_HIGH, OTYPER_PP);
	GPIO_Input_Config(BUTTON_GPIO, BUTTON_PIN, PULL_NONE, &button_exti);
	GPIO_Analog_Config(AN0_GPIO, AN0_Pin, ADC1_Cycles_3);
	GPIO_Analog_Config(AN1_GPIO, AN1_Pin, ADC1_Cycles_3);

	adc1_config(&adc1_config1);
	ADC1->SQR1 |= (0x1<<ADC_SQR1_L_Pos); //2 conversions
	ADC1->SQR3 |= (AN0_Pin<<ADC_SQR3_SQ1_Pos | AN1_Pin<<ADC_SQR3_SQ2_Pos);


	while(1)
	{

#if MODE == SINGLE_NO_SCAN
		//El pulsador activará la conversión
		if(GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN) == GPIO_PIN_RESET)
		{
			delay_ms(20);
			//Solo se obtendrá el valor del ADC convertido cada vez que el botón se active
			pot0 = adc1_read_data_Polling();
		}

		/*Lectura directa cada 10ms*/
		/*
		pot = adc1_read_data();
		delay_ms(10);*/

#elif MODE == CONTINUOUS_NO_SCAN

		//Siempre leemos el valor de DR ya que es conversión continua
		pot0 = ((uint16_t)(ADC1->DR & 0x0000FFFF));

		//Solo le damos start una vez
		if(GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN) == GPIO_PIN_RESET)
		{
			delay_ms(20);
			pot0 = adc1_read_data_Polling();
		}

#elif MODE == SINGLE_SCAN

	//El pulsador activará la conversión
	if(GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN) == GPIO_PIN_RESET)
	{
		delay_ms(20);
		//Solo se obtendrá el valor del ADC convertido cada vez que el botón se active
		pot0 = adc1_read_data_Polling();
		pot1 = adc1_read_data_Polling();
	}

#endif
	}
}

/* Definición de funciones */











