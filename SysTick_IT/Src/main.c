/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 * EXPLICACIÓN DEL SYSTICK
 *
 * El contador SysTick es un contador de 24 bits que va decrementando su valor.
 * Por lo tanto, cuenta desde ( 2^24 - 1 ) hasta 0: Un total de 2^24 pulsos.
 *
 * Entonces: Periodo : (( 2^24 - 1 ) + 1) * 1/Fosc
 *
 * Porque (2^24-1) + 1?, 2^24 - 1 es el valor máximo del contador, luego, se le suma +1 porque
 * es el pulso faltante para que pase del valor 0 al valor máximo nuevamente.
 *
 * Imaginemos que empieza a contar en un valor de 5.
 * Significa que luego de 5 pulsos llegara a la cuenta de 0. Luego de 1 pulso adicional, el contador
 * inicia la cuenta nuevamente.
 * Por lo tanto, truncar un valor de 5 equivale a tener un periodo de (5+1).
 *
 * Si truncamos este valor en cualquier otro por ejemplo:
 *
 * SEGÚN MANUAL DE PROGRAMACIÓN STM32F4
 *
 * Aquí se habla sobre cyclos de reloj:
 *
 * Si quieres 100 cyclos de reloj, entonces debes cargar en RELOAD un valor de 99.
 * Se observa que -1 de lo que quieres.
 *
 * Y si quiero tiempos?
 *
 * Quiero 5ms y tengo una frecuencia de reloj de 16Mhz -> significa que T = 1/16 us
 *
 * Cuantos pulsos necesito para llegar a 5ms -> factor = tiempo/T = 16M * 5m cyclos
 * Por lo tanto, en reload irá (16M * 5m - 1)
 *
 * delay_ms(time)
 * {
 * 	SysTick -> RELOAD = (SytemCoreClock)*(5/1000) - 1;
 * }
 *
 * OJO: Tener en cuenta la frecuencia de reloj.
 *
 * Si F = 16Mhz -> Lo máximo que contará será  2097 ms (Por el valor del registro)
 * Si F = 84Mhz -> Lo máximo que contará será  399 ms (Por el valor del registro)
 *
 * Pasos:
 *
 * Desactivar SysTick
 * Configurar fuente de reloj
 * Reiniciar el valor que tiene el systick (luego del reset, tiene cualquier valor)
 * Cargar el valor deseado: X, calclar antes
 * Activamos systick
 * Esperar a que la bandera de interrupción se active
 * Apagar systick
 *
 */

/* Inclución de librerías */
#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "Config.h"
#include "RCC.h"
#include "Delay.h"
//#include "SysTick.h"

#define BIT2					*((volatile uint32_t *)(0x22006008))

#define BITBAND_PERI(a,b) 		((PERIPH_BB_BASE + (a - PERIPH_BASE)*32 + 4*b))
#define PA5						*((volatile uint32_t*)(BITBAND_PERI(GPIOA_BASE + 0x14,5)))

/* Tipos, estructuras y enumeraciones */

/* Variables globales */

/* Prototipo de funciones */

/*Función principal */

int main(void)
{
	PLL_Config(HSE_SOURCE);

	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	GPIO_CLOCK_ENABLE(A); //Habilita el clock del puerto A
	GPIO_CLOCK_ENABLE(C);  //Habilita el clock del puerto B

	//LED
	GPIOX_MODER(MODE_OUT, LED); //Pin del led como salida
	GPIOX_PUPDR(MODE_PU_NONE, LED); //Pin del led como salida
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, LED); //Very High

	//BUTTON
	// Por si no sabemos a que puerto pertenece, la definición BUTTON se encarga de activar el clock en GPIOX_CLOCK
	//RCC->AHB1ENR |= GPIOX_CLOCK(BUTTON);
	GPIOX_MODER(MODE_DIGITAL_INPUT, BUTTON);
	GPIOX_PUPDR(MODE_PU_NONE, BUTTON);

	while(1)
	{
		//Esto es bit banding
		//BIT2 = 1;
		//BIT2 = 0;

		//De la misma forma se puede para los periféricos
		PA5 = 1;
		//PA5 = 0;
		delay_ms(100);
		GPIOX_ODR(LED) = 0;
		delay_ms(100);

	}

}

/* Definición de funciones */



