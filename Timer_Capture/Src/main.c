/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "stm32f4xx.h"
#include "timer_capture.h"


/*Definiciones*/

//#define BITBAND_ACCESS(a, b)  *(volatile uint32_t*)(((uint32_t)&a & 0xF0000000) + 0x2000000 + (((uint32_t)&a & 0x000FFFFF) << 5) + (b << 2))


/**
 * 0x10 * 32 + 4 * 0 ->
 */

volatile uint32_t *flag;
volatile uint32_t *ptr;
/* Tipos, estructuras y enumeraciones */


/* Variables globales */


/* Prototipo de funciones */


/* Función principal */
int main(void)
{

	flash_config();
	/*
	PLL_Config(HSI_SOURCE);
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif
	*/

	//flag = (volatile uint32_t *)(PERIPH_BB_BASE + 0x8200);
	//ptr = &TIM3->SR;
	//*flag = 0;

	/*Input Capture*/
	timer2_ch3_gpio_config(); //Configuramos tim2_ch3 como entrada
	timer2_count_config(); //Configuramos tim2 counter
	timer2_ch3_input_capture_config(); //Configuramos tim2 input capture

	timer2_count_start(); //Comenzamos la cuenta en tim2
	timer2_ch3_input_capture_start(); // Comenzamos la medición de captura tim2

	/*Output PWM*/
	timer3_count_config(); //Configuramos tim3 como contador

	//Señal de PWM
	GPIO_Output_Config(GPIOA, 5, PUPDR_NONE, OSPEEDR_MEDIUM, OTYPER_PP);

	//Señal de sincronización
	GPIO_Output_Config(GPIOA, 7, PUPDR_NONE, OSPEEDR_MEDIUM, OTYPER_PP);

	while(1)
	{

		if (TIM3->SR & TIM_SR_UIF)
		{
			TIM3->SR = 0;
			GPIO_Write_Toggle(GPIOA, 7);
		}
	}
}

/* Definición de funciones */



