/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "stm32f4xx.h"
#include "timer_capture.h"


/*Definiciones*/

//#define BITBAND_ACCESS(a, b)  *(volatile uint32_t*)(((uint32_t)&a & 0xF0000000) + 0x2000000 + (((uint32_t)&a & 0x000FFFFF) << 5) + (b << 2))
#define LED_PWM_GPIO	GPIOA
#define LED_PWM_PIN		7
#define LED_SYNC_GPIO	GPIOA
#define LED_SYNC_PIN	5

/**
 * 0x10 * 32 + 4 * 0 ->
 */

volatile uint32_t *flag;
volatile uint32_t *ptr;
/* Tipos, estructuras y enumeraciones */


/* Variables globales */


/* Prototipo de funciones */


/* Función principal */
int main(void)
{

	flash_config();

	RCC -> CR &= ~RCC_CR_HSION_Msk;
	RCC -> CR |= RCC_CR_HSION;
	while(!(RCC->CR & RCC_CR_HSIRDY));

	RCC -> CFGR &= ~RCC_CFGR_SW_Msk;

	RCC -> CFGR &= ~RCC_CFGR_HPRE_Msk;
	RCC -> CFGR &= ~RCC_CFGR_PPRE1_Msk;
	RCC -> CFGR &= ~RCC_CFGR_PPRE2_Msk;

	// Para saber en todo momentos el valor del registro SR
	//flag = (volatile uint32_t *)(PERIPH_BB_BASE + 0x8200);
	//ptr = &TIM3->SR;
	//*flag = 0;

	//Configuración input capture
	timer2_ch3_input_capture_config(15, 0xFFFFFFFF);

	//Configuración timer 3
	timer3_count_config(15, 49);

	//Habilitamos conteo
	timer2_ch3_input_capture_start(ISR_ON);
	timer3_count_start();

	//Señal de PWM
	GPIO_Output_Config(LED_PWM_GPIO, LED_PWM_PIN, PUPDR_NONE, OSPEEDR_MEDIUM, OTYPER_PP);

	//Señal de sincronización
	GPIO_Output_Config(LED_SYNC_GPIO, LED_SYNC_PIN, PUPDR_NONE, OSPEEDR_MEDIUM, OTYPER_PP);

	while(1)
	{
		if (TIM3->SR & TIM_SR_UIF)
		{
			TIM3->SR &= ~TIM_SR_UIF;
			GPIO_Write_Toggle(LED_PWM_GPIO, LED_PWM_PIN);
		}

	}
}

/* Definición de funciones */
void LED_Toggle_IT(void)
{
	if(TIM2->SR & TIM_SR_UIF)
	{
		TIM2->SR &= ~TIM_SR_UIF;
		GPIO_Write_Toggle(LED_SYNC_GPIO, LED_SYNC_PIN);
	}
}

