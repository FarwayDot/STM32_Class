/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 *  USART:
 *  El USART es un periférico que permite la comunicación serial entre dispositivos.
 *  La comunicación puede ser Full Duplex o Half Duplex
 *  La comunicación puede ser síncrona (3 hilos) o asíncrona (2 hilos)
 *  La DATA puede ser de 8 bits o 9 bits (Registro CR1)
 *  La comunicación puede tener 1 o 2 bits de stop (Estos bits se toman de DATA)
 * 	Posee un registro BAUDRATE del tipo fraccionario (Mantida y Fracción) que depende del OVERSAMPLING
 * 		Si el OVERSAMPLING es 0, entonces, se prioriza la seguridad e integridad de los datos.
 * 		Si el OVERSAMPLING es 1, entonces, se prioriza la velocidad máxima de transmisión.
 *  Protecciónes: Paridad (Transmisión y recepción).
 *  Detección de errores: Ruido, integridad, paridad, sobrescritura (Overrun).
 *  Fuentes de interrupción: Transm completada, Recepc completada, Registro Tx vacío, Registro Rx lleno, IDLE, Overrun, Integridad errónea, Ruido, Paridad errónea, LIN break detection.
 *
 *  CALCULO BAUDRATE:
 *
 *  Dependiendo del OVERSAMPING: 					fclk
 *  									 -------------------------- = BAUDRATE
 *  									 8 * (2 - OVER8 )× USARTDIV
 *  flck:  frecuencia del USARTx, que puede depender del APB1 o APB2
 *  OVER8: Oversampling
 *  BAUDRATE: Puede ser 9600, 115200, etc.
 *  USARTDIV: Valor que se debe transformar para que encaje en la mantisa y fracción del BRR.
 *
 *  Ejmplo:
 *
 *  fclk = 16Mhz
 *  Baudrate = 115200
 *  Over8 = 0
 *  USARTDIV = 8.68056 -> mantida: 0d8 + fraccion: 0d0.6856
 *  mantisa a hexa = 0d8 = 0x8
 *  fraccion a hexa = 0d0.6856*16 = 0d10.96 -> Más cercano -> 0d11 a hexa = 0xB.
 * 	Finalmente: BRR = 0x8<<4 | 0xB
 *
 * 	En este ejemplo no ha habido carry, pero si lo hubiera, ver ejemplos en el reference manual.
 *
 * 	CONFIGURACIÓN USART:
 *
 * 	Configurar pines:
 * 		Entrada, salida, pull up, máxima velocidad, alternativa.
 * 		Algunos pines tiene funciones alternativas.
 * 		El registro AFRH y AFRL son los registro de función alternativa.
 * 		AFRL se encarga de los GPIO0->GPIO7
 * 		AFRH se encarga de los GPIO8->GPIO15
 * 		AFR en CMSIS está como AFR[0]=AFRL y AFR[1]=AFRH
 *
 * 	Configurar bits de transmisión en USARTx -> CR1
 * 	Configura bits de stop en USARTx -> CR2
 * 	Escoger oversampling en USARTx -> CR1
 * 	Paridad en USARTx -> CR1
 * 	Habilitar Tx y Rx en USARTx -> CR1
 * 	Habilitar interrupción
 * 	USARTx -> CR1 |= USART_CR1_UE;
 *
 *
 *
 */

/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "USART.h"
#include "stm32f4xx.h"


/* Definiciones */
#define SWV	0
#define NUM_BYTES 	15

#define BUTTON_USER_GPIO		GPIOC
#define BUTTON_USER_Pin			13

/* Tipos, estructuras y enumeraciones */

USARTx_Handle_t usart2_handle = {.pUSARTx = USART2};

USARTx_Config_t USART2_Config = { 	.USARTx = USART2,
									.baudrate = 9600,
									.m_bit = M_8BITS,
									.over_bit = OVER_16,
									.enable_parity = PARITY_DIS,
									.stop_bit = STOP_ONE,
									.priority = 1};

EXTI_Config_t exti_button = {.en = 0};

/* Variables globales */
uint8_t Data1[200];
uint8_t Data2[200];
uint32_t len = 0;
uint8_t DataRx[100];
uint8_t num_bytes = 0;
uint8_t rxBuffer[100];

/* Prototipo de funciones */
void USART2_Callback(void);

/* Función principal */
int main(void)
{
	uint8_t cont = 0;

	flash_config();
	PLL_Config(HSI_SOURCE); //Se comenta, ya que, el USART utiliza los 8Mhz en la librería empleada.
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	/*Configuramos USART*/
	USARTx_Init(&USART2_Config);//USART_Init(USART2, 115200); // Inicialización del USART2
	len = sprintf((char*)Data1, "Usart_Send Data correcto\r\n");
	USARTx_Send_Data(USART2, Data1, len);

	/*Activamos interrupción por USART*/
	USARTx_Init_IT(&USART2_Config);
	len = sprintf((char*)Data2, "USART configurado como interrupcion\r\n");
	USARTx_SendDataIT(&usart2_handle, Data2, len);
	if(usart2_handle.TxBusyState == USART_READY && cont==0)
	{
		memset((void *)Data2, '\0', sizeof(Data2));
	}

	/*Configuramos entradas y salidas*/
	GPIO_Output_Config(GPIOA, 5, PUPDR_NONE, OSPEEDR_HIGH, OTYPER_PP);
	GPIO_Input_Config(GPIOC, 13, PUPDR_NONE, &exti_button);

	USARTx_ReceiveDataIT(&usart2_handle, DataRx, 10);
	while(1)
	{
		GPIO_Write_Toggle(GPIOA, 5);
		delay_ms(100);

		/*Echo*/
		if(usart2_handle.RxBusyState == USART_READY && cont==0)
		{
			cont++;
			len = sprintf((char*)Data2, "\nUSART Echo: %s\r\n",DataRx);
			USARTx_SendDataIT(&usart2_handle, Data2, len);
		}
	}
}

void USART2_Callback(void)
{
	USARTx_IRQHandling(&usart2_handle);
}



