/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "stm32f4xx.h"
#include "string.h"
#include "gui.h"
#include "bmp.h"

/*Definiciones*/


//SPI
#define PIN_SPI1_NSS	4		//NSS
#define GPIO_SPI1_NSS	GPIOA
#define PIN_SPI1_SCK	5		//SCK
#define GPIO_SPI1_SCK	GPIOA
#define PIN_SPI1_MISO	6		//MISO
#define GPIO_SPI1_MISO	GPIOA
#define PIN_SPI1_MOSI	7		//MOSI
#define GPIO_SPI1_MOSI	GPIOA

//LED
#define PIN_USER_LED	10
#define GPIO_USER_LED	GPIOA

/* Tipos, estructuras y enumeraciones */



/* Variables globales */

uint8_t Msg[] = "Mensaje Velocidad";

/* Prototipo de funciones */

/*
 * @brief GPIO Config
 *
 * COnfiguración de los pines GPIO para funcionar como SPI1
 */
void SPI_GPIO_Config(void);

/*
 * @brief Inicialización del periférico SPI
 */
void SPI_Init(SPI_TypeDef *SPIx);

/*
 * @brief Envío de datos por SPI No Interrupt
 *
 * SPI_TypeDef *SPIx: Puntero al SPI que queremos usar
 * uint8_t *tx_buffer: Data
 * uint8_t len: longitud de la data
 */
void SPI_Send_Data(SPI_TypeDef *SPIx, uint8_t *pTx_buffer, uint32_t len);

/*
 * @brief Transmisión y Recepción de datos por SPI No Interrupt
 *
 * SPI_TypeDef *SPIx: Puntero al SPI que queremos usar
 * uint8_t *pTx_buffer: Data
 * uint8_t *pRx_buffer: Data
 * uint8_t len: longitud de la data
 */
void SPI_Send_Receive_Data(SPI_TypeDef *SPIx, uint8_t *pTx_buffer, uint8_t *pRx_buffer, uint32_t len);

/*
 * @brief Recepción de datos por SPI No Interrupt enEsclavo
 *
 * SPI_TypeDef *SPIx: Puntero al SPI que queremos usar
 * uint8_t *pRx_buffer: Data
 * uint8_t len: longitud de la data
 */
void SPI_Receive_Data(SPI_TypeDef *SPIx, uint8_t *pRx_buffer, uint32_t len);

/*
 * @brief Recepción de datos por SPI No Interrupt en Maestro ya que aquí generamos la señal de reloj
 *
 * SPI_TypeDef *SPIx: Puntero al SPI que queremos usar
 * uint8_t *pRx_buffer: Data
 * uint8_t len: longitud de la data
 */
void SPI_Master_Receive_Data(SPI_TypeDef *SPIx, uint8_t *pRx_buffer, uint32_t len);

/*
 * @brief Enviar un byte de datos para pruebas
 *
 * SPI_TypeDef *SPIx: Puntero al SPI que queremos usar
 * uint8_t hex_data: Byte de datos a enviar
 *
 */
void SPI_Send_Byte(SPI_TypeDef *SPIx, uint8_t hex_data);

/* Función principal */
int main(void)
{
	//Clock Config
	flash_config();
	PLL_Config(HSI_SOURCE);
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	//SPI Config
	SPI_Init(SPI1);

	//LED Config
	GPIO_Output_Config(GPIO_USER_LED, PIN_USER_LED, PUPDR_NONE, OSPEEDR_MEDIUM, OTYPER_PP);

	//NSS Low
	GPIO_Write(GPIO_SPI1_NSS, PIN_SPI1_NSS, GPIO_PIN_SET);

	//Oled Init
	OLED_Init();
	OLED_Clear(0);

	GUI_ShowString(28,0,(u8 *)"OLED Test",16,1);
	GUI_ShowString(12,16,(u8 *)"0.96\" SSD1306",16,1);
	GUI_ShowString(40,32,(u8 *)"64X128",16,1);
	GUI_ShowString(4,48,(u8 *)"www.lcdwiki.com",16,1);
	delay_ms(500);

	OLED_Clear(0);//Clear Black

	GUI_ShowString(28,2,(u8 *)"Danielita",16,1);
	GUI_DrawBMP(40,25, megusta_bmp.width, megusta_bmp.height, (uint8_t *)megusta_bmp.data, 1);

	while(1)
	{
		/*
		GPIO_Write(GPIO_SPI1_NSS, PIN_SPI1_NSS, GPIO_PIN_RESET);
		SPI_Send_Data(SPI1, Msg, (uint32_t)strlen((char *)Msg));
		GPIO_Write(GPIO_SPI1_NSS, PIN_SPI1_NSS, GPIO_PIN_SET);*/
		GPIO_Write_Toggle(GPIO_USER_LED, PIN_USER_LED);
		delay_ms(500);
	}
}

/* Definición de funciones */

void SPI_GPIO_Config(void)
{
	RCC -> AHB1ENR |= RCC_AHB1ENR_GPIOAEN; //Clock

	//GPIO_AF_Config necesita aparte la configuración del registro AFR

	//GPIOA PIN4 NSS 4
	GPIO_Output_Config(GPIO_SPI1_NSS, PIN_SPI1_NSS, PUPDR_NONE, OSPEEDR_MEDIUM, OTYPER_PP);

	//GPIOA PIN5 SCK 5
	GPIO_AF_Config(GPIO_SPI1_SCK, PIN_SPI1_SCK, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL5_Msk;
	GPIOA->AFR[0] |= 5U<<GPIO_AFRL_AFSEL5_Pos; //AF5 LOW

	//GPIOA PIN6 MISO 6
	GPIO_AF_Config(GPIO_SPI1_MISO, PIN_SPI1_MISO, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL6_Msk;
	GPIOA->AFR[0] |= 5U<<GPIO_AFRL_AFSEL6_Pos; //AF5 LOW

	//GPIOA PIN7 MOSI 7
	GPIO_AF_Config(GPIO_SPI1_MOSI, PIN_SPI1_MOSI, PUPDR_NONE, OSPEEDR_VERYHIGH, OTYPER_PP);
	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL7_Msk;
	GPIOA->AFR[0] |= 5U<<GPIO_AFRL_AFSEL7_Pos; //AF5 LOW

	return;
}


void SPI_Init(SPI_TypeDef *SPIx)
{

	//RCC
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

	//Config GPIO
	SPI_GPIO_Config();

	//BaudRate
	SPIx->CR1 &= ~SPI_CR1_BR_Msk;
	SPIx->CR1 |= 6U<<SPI_CR1_BR_Pos; //fpclk/32 , fpclk = 84Mhz

	//CPOL y CPHA
	SPIx->CR1 &= ~(SPI_CR1_CPOL_Msk | SPI_CR1_CPHA_Msk); //Modo 0
	//SPIx->CR1 |= 1U<<SPI_CR1_CPOL_Pos;
	//SPIx->CR1 |= 1U<<SPI_CR1_CPHA_Pos;

	//Seleccionar la longitud de la trama
	SPIx->CR1 &= ~SPI_CR1_DFF_Msk; //8bits

	//Configurar MSB o LSB first
	SPIx->CR1 &= ~SPI_CR1_LSBFIRST_Msk;
	//SPIx->CR1 |= 1U<<SPI_CR1_LSBFIRST_Pos;

	//Configurar el manejo del pin NSS
	SPIx->CR1 |= 1U<<SPI_CR1_SSM_Pos; //Manejado por software
	SPIx->CR1 |= 1U<<SPI_CR1_SSI_Pos; //Cuando SSM es 1 este es ahora el nuevo NSS inter no para nuestro SPI

	//Configurar el modo TI si es que fuera necesario

	//Habilitar el modo maestro
	SPIx->CR1 |= 1U<<SPI_CR1_MSTR_Pos;

	//Habilita SPI par Tx y Rx
	SPIx->CR1 |= 1U<<SPI_CR1_SPE_Pos;

	return;
}

void SPI_Send_Data(SPI_TypeDef *SPIx, uint8_t *pTx_buffer, uint32_t len)
{

	while(len>0)
	{
		//Verificar si el registro está vacío
		while(!(SPIx->SR & SPI_SR_TXE));

		if(SPIx->CR1 & SPI_CR1_DFF) // 16bits
		{
			SPIx->DR = *((uint16_t *)pTx_buffer); //Primero se castea a puntero de 16bits, luego se obtiene el contenido
			pTx_buffer+=2;							 //con el operador indirección '*'
			len -= 2;
		}
		else //8bits
		{
			//Cargar data
			*((__IO uint8_t *)&SPIx->DR) = (*pTx_buffer);
			pTx_buffer++;
			len--;
		}
	}

	//Verificar TX
	while(!(SPIx->SR & SPI_SR_TXE));

	//Verificar que el SPI esté libre
	while(SPIx->SR & SPI_SR_BSY);

	return;
}

void SPI_Send_Receive_Data(SPI_TypeDef *SPIx, uint8_t *pTx_buffer, uint8_t *pRx_buffer, uint32_t len)
{
	while(len>0)
	{
		//Verificar si el registro está vacío
		while(!(SPIx->SR & SPI_SR_TXE));

		if(SPIx->CR1 & SPI_CR1_DFF) // 16bits
		{
			SPIx->DR = *((uint16_t *)pTx_buffer); //Primero se castea a puntero de 16bits, luego se obtiene el contenido
												 //con el operador indirección '*'

			while(!(SPIx->SR & SPI_SR_RXNE)); //Se espera a recibir
			*((uint16_t *)pRx_buffer) = SPIx->DR; //Se guarda el dato recibido

			len -= 2;
			(uint16_t *)pTx_buffer++;
			(uint16_t *)pRx_buffer++;
		}
		else //8bits
		{
			//Cargar data
			SPIx->DR = (*pTx_buffer) & 0xFF;

			while(!(SPIx->SR & SPI_SR_RXNE)); //Se espera a recibir
			*pRx_buffer = SPIx->DR & 0xFF; //Se guarda el dato recibido

			pTx_buffer++;
			pRx_buffer++;
			len--;
		}

	}

	//Verificar que el SPI esté libre
	while(SPIx->SR & SPI_SR_BSY);

	return;
}

void SPI_Receive_Data(SPI_TypeDef *SPIx, uint8_t *pRx_buffer, uint32_t len)
{
	while(len>0)
	{
		//Esperamos a que la bandera de recepción está apagada
		while(!(SPIx->SR & SPI_SR_RXNE));

		if(SPIx->CR1 & SPI_CR1_DFF) // 16bits
		{
			*((uint16_t *)pRx_buffer) = SPIx->DR; //Se guarda el dato recibido

			len -= 2;
			(uint16_t *)pRx_buffer++;
		}
		else //8bits
		{
			*pRx_buffer = SPIx->DR & 0xFF; //Se guarda el dato recibido
			pRx_buffer++;
			len--;
		}
	}

	//Verificar que el SPI esté libre
	while(SPIx->SR & SPI_SR_BSY);

	return;
}

void SPI_Master_Receive_Data(SPI_TypeDef *SPIx, uint8_t *pRx_buffer, uint32_t len)
{
	while(len>0)
	{
		//Verificar si el registro Tx está vacío
		while(!(SPIx->SR & SPI_SR_TXE));

		if(SPIx->CR1 & SPI_CR1_DFF) // 16bits
		{
			//Ya que el master proporciona el CLOCK, este debe generarlo enviando un byte
			SPIx->DR = (uint16_t)0xFFFF;

			while(!(SPIx->SR & SPI_SR_RXNE)); //Se espera a recibir
			*((uint16_t *)pRx_buffer) = SPIx->DR; //Se guarda el dato recibido

			len -= 2;
			(uint16_t *)pRx_buffer++;
		}
		else //8bits
		{
			//Ya que el master proporciona el CLOCK, este debe generarlo enviando un byte
			SPIx->DR = (uint8_t)0xFF;
			while(!(SPIx->SR & SPI_SR_RXNE)); //Se espera a recibir
			*pRx_buffer = SPIx->DR & 0xFF; //Se guarda el dato recibido
			pRx_buffer++;
			len--;
		}
	}

	//Verificar que el SPI esté libre
	while(SPIx->SR & SPI_SR_BSY);

	return;

}

void SPI_Send_Byte(SPI_TypeDef *SPIx, uint8_t hex_data)
{

	//Verificar si el registro está vacío
	while(!(SPIx->SR & SPI_SR_TXE));

	//Cargar data
	*((__IO uint8_t *)&SPIx->DR) = hex_data;

	//Verificar TX
	while(!(SPIx->SR & SPI_SR_TXE));

	//Verificar que el SPI esté libre
	while(SPIx->SR & SPI_SR_BSY);

	return;
}
