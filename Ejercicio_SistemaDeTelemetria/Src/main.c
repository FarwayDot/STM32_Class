/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "USART.h"
#include "adc.h"
#include "stm32f4xx.h"


/*
 * @brief Defines para pines
 *
 * Button: Solo por si acaso
 * User_Led: Para medir que se cumpla la interrupción del timer
 * AN0: Entrada AN para potenciómetro
 */

#define BUTTON_GPIO		GPIOC
#define BUTTON_PIN		13

#define USER_LED_GPIO	GPIOA
#define USER_LED_PIN	5

#define AN0_GPIO		GPIOA
#define AN0_Pin			0		//IN0

/* Tipos, estructuras y enumeraciones */

EXTI_Config_t button_exti = {.en = 0}; //Desactivamos EXTI del GPIO

ADC1_Params_t adc1_config1 =	{		.resolution = ADC1_Res_12bit,
										.align_mode = ADC1_Right_Align,
										.clk_div = ADC1_PCLK_DIV4,
										.conversion_mode = ADC1_Continuous_Mode,
										.scan_mode = ADC1_Scan_On,
										.eocs_var = ADC1_At_Regular,
										.adc_interrupt = ADC1_Interrupt_Off,
										.adc_dma = ADC1_DMA_On,
										.seq_config = { .seq_lenght = 1,
														.seq = {0}}
									};

USARTx_Handle_t usart2_handle = {.pUSARTx = USART2};

USARTx_Config_t USART2_Config = { 	.USARTx = USART2,
									.baudrate = 115200,
									.m_bit = M_8BITS,
									.over_bit = OVER_16,
									.enable_parity = PARITY_DIS,
									.stop_bit = STOP_ONE,
									.priority = 1};

/* Variables globales */

volatile uint16_t pot0 = 0;
volatile uint32_t pwm_val = 0;
uint8_t Tx_Data[100] = {0};

/* Prototipo de funciones */
void DMA2_Stream0_Ch0_Config(void); //Extern created in stm32f4xx_it.c
void timer2_config(void);
void adc_user_handler(void);
void timer3_ch1_pwm_config(void);
void tim3_PWM_Start(uint32_t num);
void tim3_pwm_update(uint32_t num);

/* Función principal */
int main(void)
{
	flash_config();
	PLL_Config(HSI_SOURCE);
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	/*DMA*/
	DMA2_Stream0_Ch0_Config();

	/*GPIO Config*/
	GPIO_Output_Config(GPIOA, 5, PUPDR_NONE, OSPEEDR_HIGH, OTYPER_PP);

	//Configuración button
	GPIO_Input_Config(BUTTON_GPIO, BUTTON_PIN, PULL_NONE, &button_exti);

	//Configuración led
	GPIO_Output_Config(USER_LED_GPIO, USER_LED_PIN, PUPDR_NONE, OSPEEDR_HIGH, OTYPER_PP);

	//Configuración de AN0
	GPIO_Analog_Config(AN0_GPIO, AN0_Pin, ADC1_Cycles_84);

	//ADC Config
	adc1_config(&adc1_config1);
	adc1_start_regular_conversion();

	//USART1_Config
	USARTx_Init(&USART2_Config);

	//Config TIM2
	timer2_config();

	//Config TIM3
	timer3_ch1_pwm_config();
	tim3_PWM_Start(0);
	delay_ms(1000);

	while(1)
	{
		/*
		for(uint8_t i = 0; i<100;i++)
		{
			tim3_pwm_update(i);
			delay_ms(500);
		}*/
	}
}

/* Definición de funciones */

void DMA2_Stream0_Ch0_Config()
{
	//Habilitar reloj
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;

	//Deshabilitar stream en caso está habilitado
	DMA2_Stream0->CR &= ~DMA_SxCR_EN;

	//Verificar cambio (demora un poco debido a que termina de transferir data anterior)
	while(DMA2_Stream0->CR & DMA_SxCR_EN);

	//Deshabilitar banderas en LIFCR o HIFCR  antes de habilitar stream
	DMA2->LIFCR |= ((0xF<<2) + 1U);

	//Seleccionar el peripheral address (En este caso del ADC en Memory Map + registro a leer)
	DMA2_Stream0->PAR = (uint32_t)(0x40012000 + 0x4C); //ADC Base + DR register
	//DMA2_Stream4->PAR = (uint32_t)&(ADC1->DR) //Equivalente

	//Seleccionar el memory address(Dirección del buffer donde se almacena)
	DMA2_Stream0->M0AR = (uint32_t)(&pot0);

	//Configurar el total número de datos a transferirse
	DMA2_Stream0->NDTR = 1U;

	//Seleccionar el canal DMA
	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL_Msk; //Channel 0 del Stream 0 ch0

	//Se omite aquí un paso del reference manual

	//Configurar prioridad
	DMA2_Stream0->CR &= ~DMA_SxCR_PL;
	DMA2_Stream0->CR |= (0b11U<<DMA_SxCR_PL_Pos); //High priority

	//Configurar Directo Mode o FIFO
	DMA2_Stream0->FCR &= ~DMA_SxFCR_DMDIS; //Direct mode

	//Fifo threshold (no afecta en nada si utilizamos el direct mode)

	/*Configurar modo de transferencia, tamaño de datos, modo circutlar, etc*/

	//Peripheral address size offset
	DMA2_Stream0->CR &= ~DMA_SxCR_PINCOS; //None

	//Memory data size
	DMA2_Stream0->CR &= ~DMA_SxCR_MSIZE;
	DMA2_Stream0->CR |= (0b01U<<DMA_SxCR_MSIZE_Pos); //half word - 16 bit

	//Peripheral data size
	DMA2_Stream0->CR &= ~DMA_SxCR_PSIZE;
	DMA2_Stream0->CR |= (0b01U<<DMA_SxCR_PSIZE_Pos); //half word - 16 bit

	//Peripheral increment mode (el periférico es fijo)
	DMA2_Stream0->CR &= ~DMA_SxCR_PINC_Msk;

	//Memory increment mode
	DMA2_Stream0->CR &= ~DMA_SxCR_MINC_Msk;

	//Modo circular
	DMA2_Stream0->CR |= (1U<<DMA_SxCR_CIRC_Pos);

	//Configurar interrupciones
	DMA2_Stream0->CR |= ((1U<<DMA_SxCR_DMEIE_Pos)|(1U<<DMA_SxCR_TEIE_Pos)|(1U<<DMA_SxCR_HTIE_Pos)|(1U<<DMA_SxCR_TCIE_Pos));

	NVIC_EnableIRQ(DMA2_Stream0_IRQn);

	//Habilitar el stream
	DMA2_Stream0->CR |= DMA_SxCR_EN;

}

void timer2_config(void)
{
	/*Activamos RCC del TIM2*/
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	/*Deshabilitamos conteo*/
	TIM2->CR1 &= ~TIM_CR1_CEN;
	/*Deshabilitamos banderas*/
	TIM2 -> DIER &= ~TIM_DIER_UIE;
	TIM2->CCER &= ~(TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E);
	/*Calculo del prescaler*/
	TIM2->PSC = 8400U - 1U;
	/*Calculo del auto-reload*/
	TIM2->ARR = 10000U - 1U;
	/*Actualizamos valores*/
	TIM2->EGR |= TIM_EGR_UG;
	/*Interrupción*/
	TIM2 -> DIER |= TIM_DIER_UIE;
	NVIC_EnableIRQ(TIM2_IRQn);
	/*Activamos conteo*/
	TIM2->CR1 |= TIM_CR1_CEN;
}

void TIM2_Callback(void)
{
	uint8_t len = 0;

	//Verificamos que se cumple el tiempo con el toggle
	GPIO_Write_Toggle(USER_LED_GPIO, USER_LED_PIN);

	//Enviamos data
	len = sprintf((char*)Tx_Data, "%u\n", pot0);
	USART_Send_Data(USART2, Tx_Data, len);

	//salida pwm actualizada
	pwm_val = (((uint32_t)pot0)*100)/4095;

	tim3_pwm_update(pwm_val);

	return;
}

void timer3_ch1_pwm_config(void)
{
	/*Deshabilitar captura e interrupciones*/

	TIM3->CR1 &= ~TIM_CR1_CEN_Msk;

	TIM3->CCER &= ~TIM_CCER_CC1E_Msk;

	TIM3->DIER &= ~TIM_DIER_CC1IE_Msk;

	/*GPIO TIM3_CH1_PA6_AF2_AFRL*/

	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

	GPIOA->MODER &= ~GPIO_MODER_MODER6_Msk;
	GPIOA->MODER |= GPIO_MODER_MODER6_1;

	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPD6_Msk;

	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED6_Msk;

	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL6_Msk;
	GPIOA->AFR[0] |= GPIO_AFRL_AFSEL6_1;

	/*tim3 config*/

	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

	TIM3->PSC = 84-1; //1us ticks 84-1

	TIM3->ARR = 100-1; //Periodo 10kHz 100-1

	TIM3->EGR |= TIM_EGR_UG; //Update Generation

	TIM3->CCMR1 &= ~TIM_CCMR1_CC1S_Msk;

	//Upcounting
	TIM3->CCR1 &= ~ TIM_CR1_DIR;

	//Polarity, OC1 Active in High
	TIM3->CCER &= ~TIM_CCER_CC1NP_Msk;
	TIM3->CCER &= ~TIM_CCER_CC1P;

	//Center Aligned
	TIM3->CR1 &= ~TIM_CR1_CMS_Msk;
	TIM3->CR1 |= 1U<<TIM_CR1_CMS_Pos;

	//PWM mode 1
	TIM3->CCMR1 &= ~TIM_CCMR1_OC1M_Msk;
	TIM3->CCMR1 |= 6U<<TIM_CCMR1_OC1M_Pos;

	TIM3->CCMR1 |= TIM_CCMR1_OC1PE; //Active preloaded CCR para evitar problemas
	TIM3->CR1 |= TIM_CR1_ARPE; //Active preloaded ARR para evitar problemas

	return;

}

void tim3_PWM_Start(uint32_t num)
{
	TIM3->CCR1 &= ~TIM_CCR1_CCR1_Msk; //Registro a comparar
	TIM3->CCR1 = num-1; // Valor de comparación inicial

	TIM3->CCER |= TIM_CCER_CC1E; //Habilitamos Output Compare

	//Contador en 0
	TIM3 -> CNT = 0;

	//Habilitar conteo
	TIM3 -> CR1 |= TIM_CR1_CEN;

	return;
}

void tim3_pwm_update(uint32_t num)
{
	TIM3->CCR1 = num-1;
	return;
}

void DMA_TransmitCpltCallback(void)
{
	return;
}

void DMA_HalfTransmitCpltCallback(void)
{
	return;
}






