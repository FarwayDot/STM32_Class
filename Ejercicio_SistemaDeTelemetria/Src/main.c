/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclusión de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "RCC.h"
#include "Delay.h"
#include "GPIO_Config.h"
#include "USART.h"
#include "adc.h"
#include "stm32f4xx.h"


/*
 * @brief Defines para pines
 *
 * Button: Solo por si acaso
 * User_Led: Para medir que se cumpla la interrupción del timer
 * AN0: Entrada AN para potenciómetro
 */

#define BUTTON_GPIO		GPIOC
#define BUTTON_PIN		13

#define USER_LED_GPIO	GPIOA
#define USER_LED_PIN	5

#define AN0_GPIO		GPIOA
#define AN0_Pin			0		//IN0

/* Tipos, estructuras y enumeraciones */

EXTI_Config_t button_exti = {.en = 0}; //Desactivamos EXTI del GPIO

ADC1_Params_t adc1_config1 =	{		.resolution = ADC1_Res_12bit,
										.align_mode = ADC1_Right_Align,
										.clk_div = ADC1_PCLK_DIV4,
										.conversion_mode = ADC1_Continuous_Mode,
										.scan_mode = ADC1_Scan_On,
										.eocs_var = ADC1_At_Regular,
										.adc_interrupt = ADC1_Interrupt_Off,
										.adc_dma = ADC1_DMA_On,
										.seq_config = { .seq_lenght = 1,
														.seq = {0}}
									};

USARTx_Handle_t usart2_handle = {.pUSARTx = USART2};

USARTx_Config_t USART2_Config = { 	.USARTx = USART2,
									.baudrate = 115200,
									.m_bit = M_8BITS,
									.over_bit = OVER_16,
									.enable_parity = PARITY_DIS,
									.stop_bit = STOP_ONE,
									.priority = 1};

/* Variables globales */

volatile uint16_t pot0 = 0;
volatile uint32_t pwm_val = 0;
uint8_t Tx_Data[100] = {0};

volatile uint8_t Rx_Data = 0;
uint16_t pwm_val_man = 0;

uint8_t len_data_text = 0;
uint8_t Data_Text[100] = {0};

typedef enum
{
	State_TIM2_Start,
	State_TIM2_Pause,
	State_Manual,
	State_Automatic
}Remote_Control_State_e;

typedef struct
{
	uint8_t flag_usart_rx;
	uint8_t flag_usart_rx_2;
	uint8_t flag_state1;
	uint8_t flag_state2;
	uint8_t flag_state2_last;
	uint8_t flag_tim2_update;
}User_Flags_t;

User_Flags_t user_flags = { .flag_usart_rx = 0,
							.flag_usart_rx_2 = 0,
							.flag_state1 = 0,
							.flag_state2 = 0,
							.flag_state2_last = 0,
							.flag_tim2_update = 0,
};


/* Prototipo de funciones */
void DMA2_Stream0_Ch0_Config(void); //Extern created in stm32f4xx_it.c

void timer2_config(void);

void adc_user_handler(void);

void timer3_ch1_pwm_config(void);
void tim3_pwm_update(uint32_t adc_val);

void USART2_Reconfig_IT(void);

/* Función principal */
int main(void)
{

	flash_config();
	PLL_Config(HSI_SOURCE);
	#if USE_DELAY_US == 1
		Delay_Init(SystemCoreClock/1000000);
	#else
		Delay_Init(SystemCoreClock/1000);
	#endif

	user_flags.flag_usart_rx = 1;
	user_flags.flag_state1 = State_TIM2_Start;
	user_flags.flag_state2 = State_Automatic;

	/*DMA*/
	DMA2_Stream0_Ch0_Config();

	/*GPIO Config*/
	GPIO_Output_Config(GPIOA, 5, PUPDR_NONE, OSPEEDR_HIGH, OTYPER_PP);

	//Configuración button
	GPIO_Input_Config(BUTTON_GPIO, BUTTON_PIN, PULL_NONE, &button_exti);

	//Configuración led
	GPIO_Output_Config(USER_LED_GPIO, USER_LED_PIN, PUPDR_NONE, OSPEEDR_HIGH, OTYPER_PP);

	//Configuración de AN0
	GPIO_Analog_Config(AN0_GPIO, AN0_Pin, ADC1_Cycles_84);

	//ADC Config
	adc1_config(&adc1_config1);
	adc1_start_regular_conversion();

	//USART1_Config
	USARTx_Init(&USART2_Config);

	//Reconfig USART para no modificar la librería
	USART2_Reconfig_IT();

	//Config TIM2
	timer2_config();

	//Config TIM3
	timer3_ch1_pwm_config();
	delay_ms(1000);

	while(1)
	{

		if(user_flags.flag_usart_rx)
		{
			switch(user_flags.flag_state1)
			{
				case State_TIM2_Start: //TIM2 envía los datos cada 1seg

					//Activamos conteo
					TIM2->CR1 |= TIM_CR1_CEN;

					break;
				case State_TIM2_Pause: //TIM2 se pausa y no se envían datos

					//Pausamos conteo
					TIM2->CR1 &= ~TIM_CR1_CEN;
				default: break;
			}

			switch(user_flags.flag_state2)
			{
				case State_Manual:

						//Definimos un máximo y mínimo algo grandes por el paso de 100 en 100 pero
						//se puede mofificar
						if(Rx_Data == '+')
						{
							if(pwm_val_man<=3995)
							{
								pwm_val_man += 100 ;
							}

						}
						else if(Rx_Data == '-')
						{
							if(pwm_val_man>100)
							{
								pwm_val_man -= 100 ;
							}
						}

					break;

				case State_Automatic:

					break;

				default: break;
			}
			Rx_Data = 0;
			user_flags.flag_usart_rx = 0;
		}

	}
}

/* Definición de funciones */

void DMA2_Stream0_Ch0_Config()
{
	//Habilitar reloj
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;

	//Deshabilitar stream en caso está habilitado
	DMA2_Stream0->CR &= ~DMA_SxCR_EN;

	//Verificar cambio (demora un poco debido a que termina de transferir data anterior)
	while(DMA2_Stream0->CR & DMA_SxCR_EN);

	//Deshabilitar banderas en LIFCR o HIFCR  antes de habilitar stream
	DMA2->LIFCR |= ((0xF<<2) + 1U);

	//Seleccionar el peripheral address (En este caso del ADC en Memory Map + registro a leer)
	DMA2_Stream0->PAR = (uint32_t)(0x40012000 + 0x4C); //ADC Base + DR register
	//DMA2_Stream4->PAR = (uint32_t)&(ADC1->DR) //Equivalente

	//Seleccionar el memory address(Dirección del buffer donde se almacena)
	DMA2_Stream0->M0AR = (uint32_t)(&pot0);

	//Configurar el total número de datos a transferirse
	DMA2_Stream0->NDTR = 1U;

	//Seleccionar el canal DMA
	DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL_Msk; //Channel 0 del Stream 0 ch0

	//Se omite aquí un paso del reference manual

	//Configurar prioridad
	DMA2_Stream0->CR &= ~DMA_SxCR_PL;
	DMA2_Stream0->CR |= (0b11U<<DMA_SxCR_PL_Pos); //High priority

	//Configurar Directo Mode o FIFO
	DMA2_Stream0->FCR &= ~DMA_SxFCR_DMDIS; //Direct mode

	//Fifo threshold (no afecta en nada si utilizamos el direct mode)

	/*Configurar modo de transferencia, tamaño de datos, modo circutlar, etc*/

	//Peripheral address size offset
	DMA2_Stream0->CR &= ~DMA_SxCR_PINCOS; //None

	//Memory data size
	DMA2_Stream0->CR &= ~DMA_SxCR_MSIZE;
	DMA2_Stream0->CR |= (0b01U<<DMA_SxCR_MSIZE_Pos); //half word - 16 bit

	//Peripheral data size
	DMA2_Stream0->CR &= ~DMA_SxCR_PSIZE;
	DMA2_Stream0->CR |= (0b01U<<DMA_SxCR_PSIZE_Pos); //half word - 16 bit

	//Peripheral increment mode (el periférico es fijo)
	DMA2_Stream0->CR &= ~DMA_SxCR_PINC_Msk;

	//Memory increment mode
	DMA2_Stream0->CR &= ~DMA_SxCR_MINC_Msk;

	//Modo circular
	DMA2_Stream0->CR |= (1U<<DMA_SxCR_CIRC_Pos);

	//Configurar interrupciones
	DMA2_Stream0->CR |= ((1U<<DMA_SxCR_DMEIE_Pos)|(1U<<DMA_SxCR_TEIE_Pos)|(1U<<DMA_SxCR_HTIE_Pos)|(1U<<DMA_SxCR_TCIE_Pos));

	NVIC_EnableIRQ(DMA2_Stream0_IRQn);

	//Habilitar el stream
	DMA2_Stream0->CR |= DMA_SxCR_EN;

}

void timer2_config(void)
{
	/*Activamos RCC del TIM2*/
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	/*Deshabilitamos conteo*/
	TIM2->CR1 &= ~TIM_CR1_CEN;
	/*Deshabilitamos banderas*/
	TIM2 -> DIER &= ~TIM_DIER_UIE;
	TIM2->CCER &= ~(TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E);
	/*Calculo del prescaler*/
	TIM2->PSC = 8400U - 1U;
	/*Calculo del auto-reload*/
	TIM2->ARR = 10000U - 1U;
	/*Actualizamos valores*/
	TIM2->EGR |= TIM_EGR_UG;
	/*Interrupción*/
	TIM2 -> DIER |= TIM_DIER_UIE;
	NVIC_EnableIRQ(TIM2_IRQn);
	/*Activamos conteo*/
	TIM2->CR1 |= TIM_CR1_CEN;
}

void TIM2_Callback(void)
{
	uint8_t len = 0;

	//Verificamos que se cumple el tiempo con el toggle
	GPIO_Write_Toggle(USER_LED_GPIO, USER_LED_PIN);

	//Print

	switch(user_flags.flag_state2)
	{
		case State_Manual: //Esperamos a que aumente o diminuya PWM con caracteres

			//Enviamos data
			len = sprintf((char*)Tx_Data,"Man: %u\n", pwm_val_man);
			USART_Send_Data(USART2, Tx_Data, len);
			tim3_pwm_update(pwm_val_man);

			break;

		case State_Automatic: //El ADC controla actualiza el valor del pwm

			//Enviamos data
			len = sprintf((char*)Tx_Data, "Auto: %u\n", pot0);
			USART_Send_Data(USART2, Tx_Data, len);
			tim3_pwm_update(pot0);

			break;

		default: break;

	}

	return;
}

void timer3_ch1_pwm_config(void)
{
	/*Deshabilitar captura e interrupciones*/

	TIM3->CR1 &= ~TIM_CR1_CEN_Msk;

	TIM3->CCER &= ~TIM_CCER_CC1E_Msk;

	TIM3->DIER &= ~TIM_DIER_CC1IE_Msk;

	/*GPIO TIM3_CH1_PA6_AF2_AFRL*/

	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

	GPIOA->MODER &= ~GPIO_MODER_MODER6_Msk;
	GPIOA->MODER |= GPIO_MODER_MODER6_1;

	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPD6_Msk;

	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED6_Msk;

	GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL6_Msk;
	GPIOA->AFR[0] |= GPIO_AFRL_AFSEL6_1;

	/*tim3 config*/

	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

	TIM3->PSC = 84-1; //1us ticks 84-1

	TIM3->ARR = 100-1; //Periodo 10kHz 100-1

	TIM3->EGR |= TIM_EGR_UG; //Update Generation

	TIM3->CCMR1 &= ~TIM_CCMR1_CC1S_Msk;

	//Upcounting
	TIM3->CCR1 &= ~ TIM_CR1_DIR;

	//Polarity, OC1 Active in High
	TIM3->CCER &= ~TIM_CCER_CC1NP_Msk;
	TIM3->CCER &= ~TIM_CCER_CC1P;

	//Center Aligned
	TIM3->CR1 &= ~TIM_CR1_CMS_Msk;
	TIM3->CR1 |= 1U<<TIM_CR1_CMS_Pos;

	//PWM mode 1
	TIM3->CCMR1 &= ~TIM_CCMR1_OC1M_Msk;
	TIM3->CCMR1 |= 6U<<TIM_CCMR1_OC1M_Pos;

	TIM3->CCMR1 |= TIM_CCMR1_OC1PE; //Active preloaded CCR para evitar problemas
	TIM3->CR1 |= TIM_CR1_ARPE; //Active preloaded ARR para evitar problemas

	TIM3->CCR1 &= ~TIM_CCR1_CCR1_Msk; //Registro a comparar
	TIM3->CCR1 = 10-1; // Valor de comparación inicial

	TIM3->CCER |= TIM_CCER_CC1E; //Habilitamos Output Compare

	//Contador en 0
	TIM3 -> CNT = 0;

	//Habilitar conteo
	TIM3 -> CR1 |= TIM_CR1_CEN;

	return;
}

/*
 * @brief Update PWM output
 *
 * adc_val: Valor del ADC de 0-4095
 *
 */

void tim3_pwm_update(uint32_t adc_val)
{
	if((adc_val>0) & (adc_val< 4096))
	{
		//Conversión adc a pwm
		pwm_val = (adc_val*100)/4095;

		//Actualizamos pwm
		TIM3->CCR1 = pwm_val-1U;
	}

	return;
}

/*
 * @brief Reconfig USART : RECEPTION_IT, PRIORITY
 */

void USART2_Reconfig_IT(void)
{
	//desactivamos transmisión y recepción y usart
	USART2->CR1 &= ~(1U<<USART_CR1_UE_Pos | 1U<<USART_CR1_TE_Pos | 1U<<USART_CR1_RE_Pos | 1U<<USART_CR1_IDLEIE_Pos);
	//rx interr enable (ORE no lo tocamos por ahora, solo es para un byte de datos)
	USART2->CR1 |= (1U<<USART_CR1_RXNEIE_Pos);
	//NVIC
	NVIC_EnableIRQ(USART2_IRQn);
	NVIC_SetPriority(USART2_IRQn, 6U); //prior 6 : debe ser mayor que dma2_stream0 y tim2
	//habilitamos tx, rx y usart
	USART2->CR1 |= 1U<<USART_CR1_TE_Pos | 1U<<USART_CR1_RE_Pos;
	USART2->CR1 |= 1U<<USART_CR1_UE_Pos;
}

/*
 * @brief Usart dentro del hanlder del USART2 para la recepción
 */
void USART2_Callback(void)
{
	Rx_Data = USART2->DR; //Recepcionamos dato y la bandera se desactiva automáticamente

	switch(Rx_Data)
	{
	case 'S':
		user_flags.flag_state1 = State_TIM2_Start;
		len_data_text = sprintf((char*)Data_Text, "Mode Start Transmision\r\n");
		USARTx_Send_Data(USART2, Data_Text, len_data_text);

		break;
	case 'P':
		user_flags.flag_state1 = State_TIM2_Pause;
		len_data_text = sprintf((char*)Data_Text, "Mode Pause Transmision\r\n");
		USARTx_Send_Data(USART2, Data_Text, len_data_text);
		break;
	case 'M':

		if(user_flags.flag_state2 == State_Manual)
		{
			user_flags.flag_state2 = State_Automatic;
			user_flags.flag_state2_last = user_flags.flag_state2;
			len_data_text = sprintf((char*)Data_Text, "Mode Automatic\r\n");
			USARTx_Send_Data(USART2, Data_Text, len_data_text);
		}
		else if(user_flags.flag_state2 == State_Automatic)
		{
			user_flags.flag_state2 = State_Manual;
			user_flags.flag_state2 = user_flags.flag_state2;
			len_data_text = sprintf((char*)Data_Text, "Mode Manual\r\n");
			USARTx_Send_Data(USART2, Data_Text, len_data_text);
		}

		break;
	default: break;
	}

	user_flags.flag_usart_rx = 1;
	return;
}
void DMA_TransmitCpltCallback(void)
{
	return;
}

void DMA_HalfTransmitCpltCallback(void)
{
	return;
}






