/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"

//#define AHB1_BASE 	0x40020000UL // Dirección donde empieza AHB1
//#define RCC_BASE	(AHB1_BASE | 0x3800UL) // Dirección donde empieza RCC
//#define RCC_CR		*((volatile uint32_t *) (RCC_BASE + 0x00U)) //Apuntamos a CR de RCC y obtenemos su contenido
//
//#define RCC_CFGR	*((volatile uint32_t *) (RCC_BASE + 0x04U))
//
//#define HSEON_Bit	16
//#define HSERDY_Bit	17
//#define HSEBYP_Bit	18


/***************** Variables globales *****************/

uint32_t systemFreq = 0;

/***************** Prototipo de funciones *****************/


/*
 * Configuración de la flash
 */
void flash_config(void);


/*
 * Selecciona el HSE como sysclk
 */
void HSE_Config(void);

/*
 * Selecciona el HSI como sysclk
 */
void HSI_Config(void);

/*
 * Configurar PLL a 84Mhz
 */
void PLL_Config(uint8_t Source);

/***************** Main *****************/

int main(void)
{
	/*Esta forma es lo mismo que arriba pero sin defines*/
	/*
	volatile uint8_t *RCC_CR = (volatile uint32_t* )(RCC_BASE + 0x00);
	*RCC_CR = 0; //Cambia el contenido del registro
	*/

//	RCC_CR |= (1<<HSEON_Bit) | (1<<HSEBYP_Bit);
//	while(!(RCC_CR & (1<<HSERDY_Bit))); //Wait to HSERDY


	/*Inicia la configuración inicial del clock*/
	flash_config();
	/*SystemCoreClock está en la CMSIS y contiene la frecuenciq del procesador*/
	systemFreq = SystemCoreClock;

	/*Configuramos el PLL*/
	PLL_Config(1);
	/*Revisamos el valor del SystemCoreClock*/
	systemFreq = SystemCoreClock;

	for(;;);
}

/***************** Definición de funciones *****************/

void flash_config(void)
{
	/**Se habilita por recomendación*/
	FLASH -> ACR |= 1<<9;
	FLASH -> ACR |= 1<<10;
	FLASH -> ACR |= 1<<8;

	/*Se habilitan algunos clocks*/
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
}

void HSI_Config(void)
{
	/*Activamos el HSE*/
	RCC->CR |= RCC_CR_HSION;
	/*Esperamos a que esté listo el oscilador*/
	while(!(RCC->CR & RCC_CR_HSIRDY));
	/*Seleccionamos el cambio a HSE*/
	RCC->CFGR &=~ RCC_CFGR_SW_Msk;
//	RCC->CFGR |= RCC_CFGR_SW_HSI; //No es necesario activarlo si vas a utilizar PLL
	/*Esperamos a que esté listo el cambio de oscilador*/
//	while(RCC->CFGR & RCC_CFGR_SWS_HSI); //Revisar antes de usar
	/*Actualiza SystemCoreClock*/
	SystemCoreClockUpdate();
}

void HSE_Config(void)
{
	/*Activamos el HSE*/
	RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
	/*Esperamos a que esté listo el oscilador*/
	while(!(RCC->CR & RCC_CR_HSERDY));
	/*Seleccionamos el cambio a HSE*/
	RCC->CFGR &=~ RCC_CFGR_SW_Msk;
//	RCC->CFGR = RCC_CFGR_SW_HSE; //No es necesario activarlo si vas a utilizar PLL
	/*Esperamos a que esté listo el cambio de oscilador*/
//	while(!(RCC->CFGR & RCC_CFGR_SWS_HSE));
	/*Actualiza SystemCoreClock*/
	SystemCoreClockUpdate();
}

void PLL_Config(uint8_t Source)
{
	/*Apagamos el PLL  por las dudas*/
	RCC -> CR &= ~RCC_CR_PLLON_Msk;

	/*Escojemos fuente de reloj para PLL*/
	if(Source == 1)
	{
		HSE_Config(); //FOSC= 8Mhz, M=/4, N=*168, P=1(/4)
		/*Configurar la fuente de reloj de PLL*/
		RCC -> PLLCFGR |= RCC_PLLCFGR_PLLSRC_HSE;
	}
	else
	{
		HSI_Config(); //FOSC= 16Mhz, M=/8, N=*168, P=1(/4)
		/*Configurar la fuente de reloj de PLL*/
		RCC -> PLLCFGR |= RCC_PLLCFGR_PLLSRC_HSI;
	}

	SystemCoreClockUpdate();
	systemFreq = SystemCoreClock;

	/*Configurar M,N,P,Q*/

	// 8Mhz / 4 = 2Mhz
	RCC -> PLLCFGR &= ~RCC_PLLCFGR_PLLM;
	RCC -> PLLCFGR |= (4<<0); //M 1-2Mhz

	//2Mhz * 84 = 168Mhz
	RCC -> PLLCFGR &= ~RCC_PLLCFGR_PLLN;
	RCC -> PLLCFGR |= (168<<6);//N 192-472Mhz

	//336Mhz / 2 = 84Mhz
	RCC -> PLLCFGR &= ~RCC_PLLCFGR_PLLP;
	RCC -> PLLCFGR |= (1<<16);//P <=84Mhz

	//Q <= 48Mhz (Opcional Configurar
	//RCC -> PLLCFGR &= ~RCC_PLLCFGR_PLLQ;
	//RCC -> PLLCFGR |= (4<<24);

	/*Habilitar el PLL*/
	RCC -> CR |= RCC_CR_PLLON;

	/*Esperamos a que esté listo el cambio de oscilador*/
	while(!(RCC->CR & RCC_CR_PLLRDY));

	/*Configurar Prescalers*/

	RCC -> CFGR &= ~RCC_CFGR_PPRE2_Msk;
	RCC -> CFGR |= RCC_CFGR_PPRE2_DIV1; //APB2 <=84Mhz

	RCC -> CFGR &= ~RCC_CFGR_PPRE1_Msk;
	RCC -> CFGR |= RCC_CFGR_PPRE1_DIV2; //APB1 <=42Mhz

	/*Configurar la latencia de la flash (Revisar Pag. 46 ref. manual STM32F401X)*/
	FLASH -> ACR &= ~FLASH_ACR_LATENCY;
	FLASH -> ACR |= FLASH_ACR_LATENCY_2WS;

	/*Seleccionar la fuente dek sysclk*/
	RCC->CFGR 	&= ~RCC_CFGR_SW_Msk;
	RCC -> CFGR |= RCC_CFGR_SW_PLL;

	/*Esperamos a que esté listo el cambio de oscilador*/
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	/*Actualiza SystemCoreClock*/
	SystemCoreClockUpdate();
}

/*Para enviar texto por la terminal del STMCubeIDE
 * Solo sirve cuando trabajas a una sola frecuencia de reloj
 * Se debe configurar el Debuger Configuration
 * Se debe ingresar a SWV ITM Data Console (Window -> Show View -> SWV)
 * Se debe configurar el terminal al Canal 0 y darle start (Botón Rojo con una R)
 * */
int __io_putchar(int ch)
{
	uint8_t c = ch & 0xFF;
	ITM_SendChar(c);
	return ch;
}

