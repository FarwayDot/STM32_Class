/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/***************** Inclución de librerías *****************/
#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"

/***************** Tipos, estructuras y enumeraciones *****************/

/***************** Variables globales *****************/
uint32_t systemFreq = 0;

/***************** Prototipo de funciones *****************/

void delayMs(uint32_t delay);
void GPIOA_Config(void);
void GPIOC_Config(void);
void flash_config(void);

/***************** Función principal *****************/

int main(void)
{
	flash_config();
	systemFreq = SystemCoreClock;
	GPIOA_Config();
	GPIOC_Config();

	while(1)
	{
		if(GPIOC->IDR & (1<<13))
		{
			GPIOA -> ODR |= (1<<5);
			delayMs(100);
		}
		else
		{
			GPIOA -> ODR &= ~(1<<5);
			delayMs(100);
		}
	}
}

/***************** Definición de funciones *****************/

void delayMs(uint32_t delay)
{
	uint32_t i;
	SysTick -> LOAD = SystemCoreClock/1000;
	SysTick -> VAL = 0;
	SysTick -> CTRL |= (1<<2) | (1<<0);

	for(i=0; i<delay; i++)
	{
		while(!(SysTick -> CTRL & 1<<16));
	}
}

void flash_config(void)
{
	/**Se habilita por recomendación*/
	FLASH -> ACR |= 1<<9;
	FLASH -> ACR |= 1<<10;
	FLASH -> ACR |= 1<<8;

	/*Se habilitan algunos clocks*/
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
}

void GPIOA_Config(void)
{
	//PA5 as an output, puss-pull. high-speed, no pull up down

	RCC -> AHB1ENR |= RCC_AHB1ENR_GPIOAEN;			//GPIOA Clock Enable

	GPIOA -> MODER &= ~((1<<2*5)| (1<<(2*5+1)));	//Clear MODER
	GPIOA -> MODER |= (1<<2*5);						//Output mode

	GPIOA -> OTYPER &= ~(1<<5);						//Clear OTYPER
	GPIOA -> OTYPER &= ~(1<<5);						//Push-pull

	GPIOA -> OSPEEDR &= ~((1<<2*5)| (1<<(2*5+1)));	//Clear OSPEEDR
	GPIOA -> OSPEEDR |= ((1<<2*5)| (1<<(2*5+1)));	//Very high

	GPIOA -> PUPDR &= ~((1<<2*5)| (1<<(2*5+1)));	//Clear PUPDR
	GPIOA -> PUPDR &= ~((1<<2*5)| (1<<(2*5+1)));	//No pull-up/down
}

void GPIOC_Config(void)
{
	//PC13 as an input

	RCC -> AHB1ENR |= RCC_AHB1ENR_GPIOCEN;			//GPIOC Clock Enable

	GPIOC -> MODER &= ~((1<<2*13)|(1<<(2*13+1)));	//Clear MODER
	GPIOC -> MODER &= ~((1<<2*13)|(1<<(2*13+1)));	//Input mode

	GPIOC -> PUPDR &= ~((1<<2*13)| (1<<(2*13+1)));	//Clear PUPDR
	GPIOC -> PUPDR &= ~((1<<2*13)| (1<<(2*13+1)));	//pull-up
}


